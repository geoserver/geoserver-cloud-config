# This file contains the default and sample externalized configuration for the GeoServer Control Flow extension
# and is automatically imported by geoserver.yml
# 
# When geoserver.extension.control-flow.use-properties-file is false (default), the configuration properties defined
# under geoserver.extension.control-flow.properties are used for devOps friendlyness.
#
# Additionally, using this externalized configuration allows to use SpEL expressions (and specially the cpu.cores property placeholder)
# to assign dynamic limits based on the allocated number of CPU cores in each container.
#
# For example, a property value of "${cpu.cores} * 2" will resolve to two times the number of cores allocated to the container.
# Following standard Spring Boot YAML configuratio guidelines, it is recommended to enclose property names in '[]'. Additionally
# it is recommended to enclose values in "" to ensure the expressions are lazily evaluated by our custom resolver.
#
# Check out the examples bellow, uncomment them and teak them as necessary. 
# -----------
# The control-flow module for GeoServer allows the administrator to control and throttle requests
#
# Performance: the maximum throughput in GetMap requests is usually achieved with at most 2 times the number of CPU cores requests to run in parallel. 
# Resource control: The WMS request limits allow to control the amount of memory used per request, but an OutOfMemoryError is still possible if too
# many requests run in parallel.
# Fairness: a single user should not be able to overwhelm the server with a lot of requests, leaving other users with tiny slices of the overall processing power.
# 
# The control flow method does not normally reject requests, it just queues up those in excess and executes them late. However, it’s possible to
# configure the module to reject requests that have been waited in queue for too long.

geoserver:
  extension:
    control-flow:
      # Enabled/disable the extension. The control-flow placeholder allows to use a short environment variable. E.g. export CONTROL_FLOW=false
      enabled: ${control-flow:true}
      # Whether to use the traditional control-flow.properties file in the data directory instead of the externalized config properties
      use-properties-file: false
      properties:
        ##############################################
        ### TIMEOUT
        ### Number of seconds a request can stay queued waiting for execution. If the request does
        ### not enter execution before the timeout expires it will be rejected.
        '[timeout]': 10
        ##############################################
        ### Total OWS request count
        ### ows.global: Global number of OWS requests executing in parallel
        '[ows.global]': "${cpu.cores} * 2"
        ##############################################
        ### PER REQUEST CONTROL
        ### per request type control can be demanded using the following syntax: ows.<service>[.<request>[.<outputFormat>]]=<count>
        ### Where:
        ### <service> is the OWS service in question (at the time of writing can be wms, wfs, wcs)
        ### <request>, optional, is the request type. For example, for the wms service it can be GetMap, GetFeatureInfo, DescribeLayer, GetLegendGraphics, GetCapabilities
        ### <outputFormat>, optional, is the output format of the request. For example, for the wms GetMap request it could be image/png, image/gif and so on.
        '[ows.wms]': "${cpu.cores} * 4" # more allowed for GetFeatureInfo/DescribeLayer/etc.
        '[ows.wms.getmap]': "${cpu.cores} * 2" # limit GetMap to 2 * cores
        '[ows.wps.execute]': "${cpu.cores}"
        #'[ows.wfs.getfeature.application/msexcel]': 2
        ### GeoWebCache contributes three cached tiles services: WMS-C, TMS, and WMTS. It is also possible to use the
        ### Control flow module to throttle them, by adding the following rule to the configuration file:
        '[ows.gwc]': "${cpu.cores} * 4"
        ##############################################
        ### PER USER CONCURRENCY CONTROL 
        ### There are two mechanisms to identify user requests. The first one is cookie based, so it will work fine for
        ### browsers but not as much for other kinds of clients. The second one is ip based, which works for any type of
        ### client but that can limit all the users sitting behind the same router
        ### user: maximum number of requests a single user can execute in parallel.
        ### ip: maximum number of requests a single ip address can execute in parallel.
        #'[user]': "${cpu.cores}"
        #'[ip]': "6"
        ### It is also possible to make this a bit more specific and throttle a single ip address instead by using the following:
        ### ip.<ip_addr>: <count>
        ### Where <count> is the maximum number of requests the ip specified in <ip_addr> will execute in parallel.
        #'[ip.10.0.0.1]': "3 * ${cpu.cores}"
        ### To reject requests from a list of ip addresses:
        #'[ip.blacklist]': "192.168.0.7, 192.168.0.8"
        ##############################################
        ### PER USER RATE CONTROL
        ### The rate control rules allow to setup the maximum number of requests per unit of time, based either on a cookie or IP address.
        ### These rules look as follows (see “Per user concurrency control” for the meaning of “user” and “ip”):
        ### user.ows[.<service>[.<request>[.<outputFormat>]]]=<requests>/<unit>[;<delay>s]
        ### ip.ows[.<service>[.<request>[.<outputFormat>]]]=<requests>/<unit>[;<delay>s]
        #'[user.ows.wms.getmap]': "30/s"
        #'[user.ows.wps.execute]': "1000/d;30s"
        ##############################################
